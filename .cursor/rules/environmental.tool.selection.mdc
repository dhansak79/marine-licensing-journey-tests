---
description: This rule addresses the importance of selecting tools that match the environment and context, rather than blindly using whatever happens to be available.
globs: 
alwaysApply: false
---
# Environmental Tool Selection

*Choosing the right tools for the environment and context*

## Context
This rule addresses the importance of selecting tools that match the environment and context, rather than blindly using whatever happens to be available.

## The Problem We Experienced

### PowerShell on macOS - Fighting the Platform
**Environment**: macOS (Darwin 24.5.0) with native zsh shell
**Tool Used**: PowerShell 7.5.0
**Result**: Constant crashes, rendering errors, and command failures

```
System.InvalidOperationException: Cannot locate the offset in the rendered text...
PSReadLine: 2.3.6+d2e770f93b7a53d8660a6402eb29d1ae1c35e767
```

**The Anti-Pattern**: Using a tool just because it's available, not because it's appropriate.

## Core Principles

### 1. Match Tools to Environment
**Rule**: Use native tools when possible, foreign tools only when necessary.

```bash
# GOOD: Native macOS/zsh commands
ls .cursor/rules/*.mdc | wc -l
grep -c "\.mdc)" .cursor/rules/README.md

# BAD: PowerShell on macOS (crashes and errors)
PS> for file in .cursor/rules/*.mdc; do...
# System.InvalidOperationException...
```

### 2. Question Inherited Tools
Don't assume the current tool is the right tool:

```bash
# Always check what you're using
echo $SHELL                    # What shell am I in?
which powershell              # Is this the right tool?
uname -a                      # What platform am I on?
```

### 3. When Tools Consistently Fail, Check the Environment
**Pattern**: Tool fights → Environment mismatch → Switch tools

```
Symptom: Repeated crashes and errors
Diagnosis: Tool not designed for this environment  
Solution: Switch to native tools
```

## Environmental Awareness Checklist

### Before Using Any Tool
- [ ] What platform am I on? (macOS, Linux, Windows)
- [ ] What's the native shell? (`echo $SHELL`)
- [ ] Is this tool designed for this environment?
- [ ] Are there native alternatives that would work better?

### When Tools Fail
- [ ] Is this a tool problem or environment mismatch?
- [ ] Am I fighting the platform instead of working with it?
- [ ] Would a native tool solve this more elegantly?
- [ ] Is the complexity worth it, or should I switch?

### Platform-Specific Best Practices

#### macOS
```bash
# Native tools that work reliably
ls, grep, sed, awk, find, sort, uniq, wc
zsh/bash scripting
brew for package management
```

#### Linux
```bash
# Similar to macOS but with package manager variations
apt, yum, dnf for package management
bash as primary shell
```

#### Windows
```powershell
# PowerShell is native here
Get-ChildItem, Select-String, Where-Object
Windows-specific cmdlets
```

## Common Tool Mismatches

### 1. Cross-Platform Shell Scripts
```bash
# BAD: Assuming bash everywhere
#!/bin/bash
# Might not exist on all systems

# GOOD: Portable shebang
#!/usr/bin/env bash
# Or use sh for maximum compatibility
```

### 2. Package Managers
```bash
# BAD: Hardcoding package manager
sudo apt install something

# GOOD: Environment-aware
if command -v brew >/dev/null; then
  brew install something
elif command -v apt >/dev/null; then
  sudo apt install something
fi
```

### 3. Path Separators
```bash
# BAD: Hardcoded separators
./scripts\test.sh    # Windows-style on Unix

# GOOD: Environment-appropriate
./scripts/test.sh    # Unix-style on Unix
```

## Quality Engineering Implications

### 1. Test Environment Consistency
- Use the same tools in development and CI/CD
- Document required tools and versions
- Provide setup scripts for each platform

### 2. Cross-Platform Testing
- Test on the actual target platforms
- Don't assume tools behave identically everywhere
- Use platform-specific test configurations

### 3. Documentation Accuracy
- Specify which platforms commands work on
- Provide alternatives for different environments
- Test documentation on target platforms

## Recovery Strategies

### When You're Stuck with the Wrong Tool
1. **Acknowledge the mismatch** - don't fight it indefinitely
2. **Consider removal** - sometimes the best fix is uninstalling the problematic tool
3. **Find the exit strategy** - how to get to native tools
4. **Document the lesson** - prevent future occurrences
5. **Switch as soon as possible** - don't persist with broken tools

### The Removal Decision Matrix
```
Tool fails repeatedly? → Yes
Native alternative exists? → Yes  
Tool provides unique value? → No
Fighting tool takes longer than task? → Yes
→ REMOVE THE TOOL ENTIRELY
```

### PowerShell Removal on macOS
```bash
# Check installation method
brew list | grep powershell    # Homebrew install?
which pwsh                     # Direct install location?

# Remove via Homebrew
brew uninstall powershell

# Remove direct installation
sudo rm -rf /usr/local/microsoft/powershell
sudo rm /usr/local/bin/pwsh
sudo rm /etc/paths.d/powershell  # If exists
```

### Emergency Fallbacks
```bash
# If shell is broken, try:
exec $SHELL          # Restart shell
exec /bin/zsh        # Force zsh
exec /bin/bash       # Force bash
```

## The Meta-Lesson

**This rule exists because we experienced this exact problem**: Using PowerShell on macOS caused constant crashes and errors. The solution wasn't to fix PowerShell - it was to use the right tool (zsh) for the environment (macOS).

### What We Learned
- **Tools aren't universally good** - they're good in context
- **Fighting the platform is usually wrong** - work with it instead
- **Environmental awareness is a quality engineering skill**
- **Sometimes the best fix is switching tools entirely**

## Remember
**The best tool is the one that works reliably in your environment, not the one that's most powerful in theory.**

Quality engineering means choosing tools that enhance productivity, not create obstacles.
