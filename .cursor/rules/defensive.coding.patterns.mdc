---
description: This rule covers defensive coding practices discovered while refactoring test automation code. We found patterns of both good and bad defensive coding that need clear guidelines.
globs: 
alwaysApply: false
---
# Defensive Coding Patterns

*Lessons learned from refactoring marine licensing test automation*

## Context
This rule covers defensive coding practices discovered while refactoring test automation code. We found patterns of both good and bad defensive coding that need clear guidelines.

## Core Principles

### 1. Validate Once, Trust After
**Good Pattern:**
```javascript
async performAs(actor) {
  const exemption = actor.recalls('exemption')
  
  if (!exemption) {
    expect.fail('Exemption data must be initialized before completing task')
  }
  
  if (!exemption.publicRegister) {
    expect.fail('Public register data must be set before completing task')
  }
  
  // Now we can trust the data exists
  const consent = exemption.publicRegister.consent
  const reason = exemption.publicRegister.reason
}
```

**Bad Pattern:**
```javascript
// Redundant check after we've already validated
if (actor.hasMemoryOf('exemption')) {
  actor.updates('exemption', (exemption) => exemption.markCompleted())
}
```

### 2. Use Test Assertions, Not Generic Errors
**Good:**
```javascript
if (!exemption) {
  expect.fail('Exemption data must be initialized before completing task')
}
```

**Bad:**
```javascript
if (!exemption) {
  throw new Error('Exemption data missing')
}
```

### 3. Prevent Reference Issues with Defensive Copying
**Good:**
```javascript
constructor(data) {
  this.data = { ...data } // Create a copy to avoid reference issues
}
```

**Bad:**
```javascript
constructor(data) {
  this.data = data // Creates reference to original object
}
```

## Specific Patterns to Avoid

### 1. Redundant Memory Checks
```javascript
// BAD: Checking memory after we've already validated the data exists
const exemption = actor.recalls('exemption')
if (!exemption) {
  expect.fail('Exemption required')
}

// Later in the same method...
if (actor.hasMemoryOf('exemption')) { // REDUNDANT!
  actor.updates('exemption', (exemption) => exemption.markCompleted())
}
```

### 2. Inconsistent Validation Levels
```javascript
// BAD: Some methods check, others don't
methodA() {
  const data = this.getData()
  if (!data) throw new Error('No data')
  // use data
}

methodB() {
  const data = this.getData() // No check - inconsistent!
  // use data
}
```

### 3. Over-Defensive Coding
```javascript
// BAD: Checking the same thing multiple times
if (exemption && exemption.publicRegister && exemption.publicRegister.consent !== undefined) {
  if (exemption && exemption.publicRegister) { // REDUNDANT!
    const consent = exemption.publicRegister.consent
  }
}
```

## Best Practices

### 1. Validate Early, Fail Fast
- Check preconditions at the start of methods
- Use descriptive error messages that help debugging
- Fail immediately when assumptions are violated

### 2. Use Appropriate Error Types
- `expect.fail()` for test assertion failures
- `throw new Error()` only for unexpected system errors
- Include context in error messages

### 3. Defensive Copying Strategy
- Copy objects when storing them to prevent mutations
- Use spread operator `{ ...obj }` for shallow copies
- Consider deep copying for nested objects if needed

### 4. Logical Consistency Checks
- Ensure boolean mappings make sense (`withhold: true` â†’ `consent: false`)
- Validate that related fields are consistent
- Check that required fields are present when expected

## Common Mistakes We Found

1. **Duplicate Action Prevention**: Check if an action is already handled by a task before adding it manually
2. **Shallow Copy Issues**: Direct assignment creates references, not copies
3. **Redundant Validation**: Don't re-check what you've already validated
4. **Wrong Error Types**: Use test assertions in test code, not generic errors
5. **Logical Inconsistencies**: Ensure related fields have consistent values

## When to Apply Defensive Coding

### Always Defend Against:
- Null/undefined data from external sources
- Invalid data structures
- Missing required properties
- Logical inconsistencies in related fields

### Don't Over-Defend Against:
- Data you've already validated in the same method
- Internal method calls within the same class
- Well-established patterns that are consistently used

## Remember
> "Defensive coding should protect against real risks, not imaginary ones. Validate once, trust after." - Quality Engineering Lesson

The goal is robust code that fails clearly when assumptions are violated, without redundant checks that clutter the logic.
